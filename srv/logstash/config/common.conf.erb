filter {
    #
    # rewrite our defined globals
    #

    if [type] == 'redis' or [type] == 'redis-input' {
        mutate {
            remove_field => [ 'type' ]
        }
    }

    if [type] != '' {
        mutate {
            rename => [ "type", "@type" ]
        }
    }

    if [message] != '' {
        mutate {
            rename => [ "message", "@message" ]
        }
    }

    #
    # ignore particularly useless lines
    #

    if [@message] =~ /^(\w)*$/ or [@message] =~ /^#/ {
        drop { }
    }

    #
    # trim excessively long messages
    #

    ruby {
        code => "(event['@message'] = event['@message'][0,<%= $LOGSTASH_MESSAGE_MAXSIZE %>] and (event['tags'] ||= []) << '_groktrimmed') if event['@message'] and event['@message'].length > <%= $LOGSTASH_MESSAGE_MAXSIZE %>"
    }

    #
    # the various log types that we're interested in
    #

    <% Dir.glob("#{ENV['APP_APP_DIR']}/srv/logstash/config/filter.d/*.conf.erb") do |filter_erb_file| %>
      <%= ERB.new(File.read(filter_erb_file), nil, nil, '_filter_sub_template').result(binding) %>
    <% end %>

    #
    # type-casting for more advanced searches
    #

    if "nginx" in [tags] {
        mutate {
            convert => [ "status", "integer" ]
            convert => [ "body_bytes_sent", "integer" ]
        }
    }

    if "iis" in [tags] {
        mutate {
            convert => [ "s_port", "integer" ]
            convert => [ "sc_status", "integer" ]
            convert => [ "sc_substatus", "integer" ]
            convert => [ "win32_status", "integer" ]
            convert => [ "sc_bytes", "integer" ]
            convert => [ "cs_bytes", "integer" ]
            convert => [ "time_taken", "integer" ]
            gsub => [ "cs_referer", "\\+", " " ]
        }
    }
}

